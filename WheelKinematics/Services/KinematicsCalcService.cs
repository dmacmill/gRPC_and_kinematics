using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Grpc.Core;
using Microsoft.AspNetCore.Mvc;

// Not autogenerated, just the KinematicsCalcBase is.
namespace WheelKinematics.Services
{
    public class KinematicsCalcService : KinematicsCalc.KinematicsCalcBase
    {
        private readonly ILogger<KinematicsCalcService> _logger;
        private readonly DiffDrivePoses _diff;
        private readonly double _delta_t;
        private readonly double _track;
        private readonly double _wheel_radius;

        public KinematicsCalcService(ILogger<KinematicsCalcService> logger)
        {
            _logger = logger;

            // delta_t
            _delta_t = 0.1;

            // track length between wheels (meters)
            _track = 0.5;
            _wheel_radius = 0.1;

            // Init state for the simulated robot
            WheelVel wpl = new WheelVel{Lin = 0.0, Ang = 0.0};
            WheelVel wpr = new WheelVel{Lin = 0.0, Ang = 0.0};
            RobotPose rp = new RobotPose{X = 0.0, Y = 0.0, Th = 0.0};
            _diff = new DiffDrivePoses{
                Left = wpl,
                Right = wpr,
                Robot = rp
            };
        }


        /**
        * CalcDiffDrive - inverse and forward kinematics for getting robot position and 
        * wheel states from the 2D cmd_vel message. Done for a diff drive robot with 2 wheels, 
        * left and right.
        *
        * returns Task<DiffDrivePoses> (Task allows for async)
        */
        public override Task<DiffDrivePoses> CalcDiffDrive(CmdVel request, ServerCallContext context)
        {
            /** From https://www.roboticsbook.org/S52_diffdrive_actions.html#kinematics-in-code **/
            // The wheel vels (inverse kinematics)
            _diff.Left.Lin = (request.X - (_track/2 * request.Th)) / _wheel_radius;
            _diff.Right.Lin = (request.X + (_track/2 * request.Th)) / _wheel_radius;
            _diff.Left.Ang = _diff.Left.Lin / _wheel_radius;
            _diff.Right.Ang = _diff.Right.Lin / _wheel_radius;
            
            // Robot State (forward kinematics)
            // Try removing the Cos and Sin to retrieve the original CmdVel
            _diff.Robot.X += (_diff.Left.Lin + _diff.Right.Lin) * (_wheel_radius/2) * Math.Cos(request.Th);
            _diff.Robot.Y += (_diff.Left.Lin + _diff.Right.Lin) * (_wheel_radius/2) * Math.Sin(request.Th);
            _diff.Robot.Th += (_diff.Right.Lin - _diff.Left.Lin) * (_wheel_radius / _track);

            // mult by _delta_t to get the state after one _delta_t instead of a second
            _diff.Robot.X *= _delta_t;
            _diff.Robot.Y *= _delta_t;
            _diff.Robot.Th *= _delta_t;

            return Task.FromResult(_diff);
        }
    }
}